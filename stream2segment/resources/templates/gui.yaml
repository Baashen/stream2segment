# The next parameter, segment_select, needs some explanation:
# It is a dict-like parameter which controls which segments should be processed:
# if given, the selection is done on the database side *before* starting
# the processing and thus is much more efficient than doing the check for each segment
# inside the user-defined process function.
# The dict keys are properties of the currently processed segment (e.g., event.magnitude)
# The dict values are string expression which will be evaluated according to
# the relative key type (e.g., "==1", "[1, 4.5]" which means interval with endpoints,
# "(1,4.5)" which means interval without endpoints, ">=6", or a simple list of values: "1 3 4.5 7")
# Keys and relative types are listed below. 
# As an example: to select for processing only segments whose id is in a specified list of
# ids (say 1 4 5 67 89 342), with downloaded waveform data
# (non empty), whose event magnitude is greater in [4.5, 5.56] (endpoints included), and whose station start_time is not greater
# than 1st january 2016:
#
# segment_select:
#   has_data: true
#   id: "1 4 5 67 89 342"
#   event.latitude: "[4.5, 5.6]"
#   station.start_time: "<= 2016-01-01T00:00:00"
#
# ----------------------------------------------------
#
# Key                               Type
# =================================  =================
#    has_data                        bool
#    id                              int
#    event_distance_deg              float
#    start_time                      datetime.datetime
#    arrival_time                    datetime.datetime
#    end_time                        datetime.datetime
#
#    event.id                        str
#    event.time                      datetime.datetime
#    event.latitude                  float
#    event.longitude                 float
#    event.depth_km                  float
#    event.author                    str
#    event.catalog                   str
#    event.contributor               str
#    event.contributor_id            str
#    event.mag_type                  str
#    event.magnitude                 float
#    event.mag_author                str
#    event.event_location_name       str
#    
#    channel.id                      str
#    channel.location                str
#    channel.channel                 str
#    channel.depth                   float
#    channel.azimuth                 float
#    channel.dip                     float
#    channel.sensor_description      str
#    channel.scale                   float
#    channel.scale_freq              float
#    channel.scale_units             str
#    channel.sample_rate             float
#    
#    station.id                      str
#    station.network                 str
#    station.station                 str
#    station.latitude                float
#    station.longitude               float
#    station.elevation               float
#    station.site_name               str
#    station.start_time              datetime.datetime
#    station.end_time                datetime.datetime
#    
#    datacenter.id                   int
#    datacenter.station_query_url    str
#    datacenter.dataselect_query_url str
#    
#    run.id                          int
#    run.run_time                    datetime.datetime
#    run.program_version             str
#
#    (run refers to the download run of the segment)
#    
#    classes                         str either 'any' (segment which have at least one class assigned) or 'none' (segments with no class assigned)
#    classes.id                      int
#
# Finally, here the parameter. Each value must be a string (i.e., quoted with " or ')
# each string will be then splitted using shell-like syntax. In the (rare) cases where spaces
# should not seaprate chunks, they should be quoted again: for instance, select segments where
# its event 'author' is either 'Will Smith' or 'Ross' write:
#    event.author: "'Will Smith' Ross"
# By default, avoid processing null/empty-data segments:
segment_select:
  has_data: 'true'
  
# order segments by: specify a list of attributes as for segment_select, except 'classes' and 'classes.id'
# which are not supported here. Additionally, you can append a + or - to specify order ascending (the default when
# missing) or descending
segment_orderby:
  - event.time-  # this will sort segment according to the event time, descending (- at end)
  - event_distance_deg  # for segments with the given event.time, this will sort them ascending (no symbol defaults to +: ascending)

# set to True or False if station inventories should be passed in the processing function
# If you don't need inventories (usually useful for removing the instrumental response from the Stream object)
# set to False, as this will speed up the processing loop
# If missing (e.g., by deleting the line below), it defaults to False
inventory: True

# set to True or False if station inventories should be saved when they need to be downloaded
# If missing (e.g., by deleting the line below), it defaults to False. This parameter has effect only if inventory above is True
# Saving inventories might speed up further processing but increases db size
save_downloaded_inventory: False

# settings for spectra and filter. You can change / delete their values but you should also
# re-implement the spectra function defined in the python file:
sn_windows:
  arrival_time_shift: 0  # programmatically shifts the arrival time for every segment (in seconds). Tune if you find arrival times should be corrected after visual inspection
  signal_window: [0.1, 0.9]  # either a number (in seconds) or interval relative to the % of the cumulative

# settings for sn (signal-to-noise) spectra
sn_spectra:
  taper:
    max_percentage: 0.05
    type: 'hann'
  smoothing_wlen_ratio: 0.05  # 0 for no smoothing
  type: 'amp'  # if 'pow', then power spectra are computed, otherwise any other value defaults to amplitude spectra

###############################################################################
# Classes (label: description) for manual annotation in case of supervised classification problem
# The labels below will first be added to the db and then will show up in the GUI where one or
# more classes can be assigned to a given segment
# this parameter is optional, if missing no class labels will show in the GUI, unless already
# set by a previous config
# we leave here below an example of it: uncomment the block from ''class_labels' on, 
# and provide your own labels if needed 
###############################################################################
#class_labels:
#  Discarded: "Segment which does not fall in any other cathegory (e.g., unknown artifacts, bad formats etcetera)"
#  Unknown: "Segment which is either: unlabeled (not annotated) or unclassified"
#  Ok: "Segment with no artifact"
#  LowS2N: "Segment has a low signal-to-noise ratio"
#  Aftershock: "Segment with non overlapping multi-events recorded (aftershock)"
#  MultiEvent: "Segment with overlapping multi-events recorded (no aftershock)"
#  BadCoda: "Segment with a bad coda (bad decay)"
  
# custom paremeters below. You can change / delete their values but you should also
# re-implement the spectra function defined in the python file:
filter_settings:
  remove_response_water_level: 60
  remove_response_output: 'ACC'
  bandpass_freq_max: 20  # the max frequency, in Hz:
  bandpass_max_nyquist_ratio: 0.9
  bandpass_corners: 2