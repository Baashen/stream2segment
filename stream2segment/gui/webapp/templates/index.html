<!DOCTYPE html>
<html>
<head>
<script src="static/js/moment.min.js"></script>
<script src="static/js/Chart.js"></script>
<script src="static/js/angular.min.js"></script>
<link href="static/css/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="static/css/mystyle.css" rel="stylesheet" media="screen">
<title>{{ title }}</title>
</head>

<body ng-app="myApp" ng-controller="myController">


<div class="container-fluid fullheight">
<div class="row fullheight">
	<div class="col-md-2 fullheight left-panel">
		<div class=navigator>
			<input ng-show="isEditingIndex" ng-model="currentSegmentText" type="numeric" class="form-control"
			placeholder="Enter number in [ 1, {{ '{{' }} elements.length {{ '}}' }} ] (ESC to exit)"
			ng-keyup="$event.keyCode == 13 ? setCurrentIndexFromText() : ($event.keyCode == 27 ? isEditingIndex=false : null)">
			<a  ng-show="!isEditingIndex" ng-click="isEditingIndex=true">
				Segment {{ '{{' }} currentIndex + 1 {{ '}}' }} of {{ '{{' }} elements.length {{ '}}' }}
			</a>
			<!-- as these two buttons are right floated (see mystyle.css), the order they wil be displayed is
			inverse to the order they appear here, so we invert them
			order  -->
			<button  ng-show="!isEditingIndex" class='btn btn-default' ng-click="setNextIndex()" >&rarr;</button>
			<button  ng-show="!isEditingIndex" class='btn btn-default' ng-click="setPreviousIndex()">&larr;</button>
		</div>
		<div class="checkbox">
			
    
    		<label>
      			<input type="checkbox" ng-model="showFiltered"
      				ng-change="toggleFilter()"> View Rem.resp+filtered
    		</label>
  		</div>
		<div class="panel panel-default">
  			<!-- Default panel contents -->
  			<div class="panel-heading">{{ '{{' }} getCurrentSegmentName() {{ '}}' }}</div>
  				<div class="panel-body">
  					<ul class="segment-info example-animate-container">
						<li class="animate-repeat" ng-repeat="info in data.metadata">
					      		<strong>{{ '{{' }} info[0] {{ '}}' }}</strong>: {{ '{{' }} info2str(info[1]) {{ '}}' }}
					    </li>
					    <li class="animate-repeat" ng-if="infos.length == 0">
					      		<strong>No info available</strong>
					    </li>
					</ul>
  				</div>
  		</div>
  		
  		<!--  <div class="dropdown">
  <button class="btn btn-primary dropdown-toggle" type="button" data-toggle="dropdown">Dropdown Example
  <span class="caret"></span></button>
  <ul class="dropdown-menu">
    <li><a href="#">HTML</a></li>
    <li><a href="#">CSS</a></li>
    <li><a href="#">JavaScript</a></li>
  </ul>
</div> -->
  		
  		<div class="panel panel-default">
  			<!-- Default panel contents -->
  			<div class="panel-heading">Class</div>
  				<div class="panel-body">
  					<!-- <div><a ng-click="classesActiveTab = 1 - classesActiveTab">Filter</a></div>-->
  					<div class="segment-class example-animate-container">
  					<div ng-repeat="class in classes">
  						<label>
							<input
							    type="checkbox"
							    value="{{ '{{' }} class.id {{ '}}' }}"
							    ng-checked="currentSegmentClassIds.indexOf(class.id) > -1"
							    ng-click="toggleClassIdSelectionForCurrentSegment(class.id)"
							> {{ '{{' }} class.id {{ '}}' }}: <strong>{{ '{{' }} class.label {{ '}}' }}</strong> ({{ '{{' }} class.count {{ '}}' }})
						</label>
					</div>
					</div>
  				</div>
  		</div>
	</div>
	<div class="col-md-6 fullheight pos-relative">
		<div class="one-third-height">
			<canvas id="canvas1.1"></canvas>
		</div>
		<div class="one-third-height">
			<canvas id="canvas2.1"></canvas>
		</div>
		<div class="one-third-height">
			<canvas id="canvas3.1"></canvas>
		</div>
	</div>
	<div class="col-md-4 fullheight pos-relative">
		<div class="one-third-height">
			<canvas id="canvas1.2"></canvas>
		</div>
		<div class="one-third-height">
			<canvas id="canvas1.3"></canvas>
		</div>
		<div class="one-third-height">
			<canvas id="canvas1.4"></canvas>
		</div>
	</div>
</div>

</div>
	
</body>
<script type="text/javascript">
/* these two options together make canvas (plots) resize automatically according to parent container size */
Chart.defaults.global.responsive = true; /* what happens?? */
Chart.defaults.global.maintainAspectRatio = false;
Chart.defaults.global.elements.point.radius = 0;
Chart.defaults.global.elements.line.fill = false;
Chart.defaults.global.elements.line.borderWidth = 1;
//Chart.defaults.global.elements.line.backgroundColor = "rgba(75,192,192,0.4)";
//Chart.defaults.global.elements.line.borderColor = "rgba(75,192,192,1)";


/* extends a line chart which displays the arrival time.
 * 
 */

 //first define the snr colors:
var snrColors = {
	noise: {
		border: "rgba(0, 125, 0, 0.55)",
		background: "rgba(0, 125, 0, 0.1)"
	},
	signal: {
		border: "rgba(125, 0, 0, 0.55)",
		background: "rgba(125, 0, 0, 0.1)"
	}
};

var traceColors = {
	border: "rgba(75,192,192,0.8)",
	background: "rgba(75,192,192,0.1)"
}

var arrivalTimeColor = "rgba(0, 0, 42, 0.7)";

var originalLineDraw = Chart.controllers.line.prototype.draw;
Chart.helpers.extend(Chart.controllers.line.prototype, {
    draw: function () {
    	originalLineDraw.apply(this, arguments);
    	
    	var chart = this.chart;
        var ctx = chart.chart.ctx;

        //IMPORTANT: ALL TIME UNITS IN MILLISECONDS!!!!
        //as a remindeer, a timestamp in milliseconds has 13 chars if integer
        var fftWindows = chart.config.options.fftWindows;
        var cumt5 = chart.config.options.cumT5;
        var cumt95 = chart.config.options.cumT95;
        
        var fftWindowsSet = fftWindows && fftWindows.length;
        var t5_95RegionSet = cumt5 && cumt95 && cumt5 < cumt95;
        
        if (fftWindowsSet || t5_95RegionSet){
        	ctx.save();
        	
        	var xaxis = chart.scales['x-axis-0'];
            var yaxis = chart.scales['y-axis-0'];
            //save a reference toi current fill style
  		  	var textFillStyle = ctx.fillStyle;
  		  	
        	if(fftWindowsSet){
	            var x1 = xaxis.getPixelForValue(fftWindows[1]); //arrival time + delay
	            
	            // paint arrival time (+ delay) line
	            ctx.beginPath();
	            ctx.moveTo(x1, yaxis.top + 12); // 12 to leave a little bit of margin
	            ctx.strokeStyle = arrivalTimeColor;
	            ctx.lineTo(x1, yaxis.bottom);
	            ctx.stroke();
	            
	         	// write arrival time caption
	            ctx.fillStyle = textFillStyle;
			  	ctx.textAlign = 'center';
	            ctx.fillText("arrival time (+delay)", x1, yaxis.top);
	
	            //paint rects:
          		var x0 = xaxis.getPixelForValue(fftWindows[0]);
          	  	var x1 = xaxis.getPixelForValue(fftWindows[1]);
          		var x2 = xaxis.getPixelForValue(fftWindows[2]);
          		var x3 = xaxis.getPixelForValue(fftWindows[3]);
          	   
              	ctx.fillStyle = snrColors.noise.background;
  			  	ctx.fillRect(x0, yaxis.top, x1-x0, yaxis.bottom - yaxis.top);
  			  	ctx.fillStyle = snrColors.signal.background;
  			  	ctx.fillRect(x2, yaxis.top, x3-x2, yaxis.bottom - yaxis.top);
	           
        	}
        	
        	if(t5_95RegionSet){
        		var x0 = xaxis.getPixelForValue(moment(cumt5));
            	var x2 = xaxis.getPixelForValue(moment(cumt95));
         
	          	ctx.fillStyle = traceColors.background;
			  	ctx.fillRect(x0, yaxis.top, x2-x0, yaxis.bottom - yaxis.top);
			  	
			  	ctx.fillStyle = textFillStyle;
			  	ctx.textAlign = 'center';
	          	ctx.fillText("5% to 95% Region", (x2+x0)/2, yaxis.top);
            }
        	
        	ctx.restore();
        }

    }
}); 


/*
init charts: 
*/
// first init the dict of options for all time plots:
var timeOpts = {
        scales: {
        	xAxes: [{
                type: 'time',
                time: {
                    parser: function(value){
                    	// override this cause moment parses as local time,
                    	// but we have times as utc
                    	// for info see:
                    	// http://www.chartjs.org/docs/#scales-time-scale
                    	// http://momentjs.com/docs/#/parsing/utc/
                		return moment.utc(value);
                    },
                    displayFormats: {
                    	second:	'HH:mm:ss',
                    	minute:	'HH:mm:ss',
                    	hour:	'MMM D, HH'
                    }
                },
                ticks:{
                	maxRotation: 0,
                	callback: function(value, index, values) {
                    	if (values.length > 2 && index == values.length - 2){
                    		// Last ticks in time scale often overlap. Remove next-to-last
                        	// in case
                            if(values[index] - value[index-1] != values[index+1] - value[index]){
                    			value = "";
                    		}
                    	}
                    	return "" + value;
                    }
                }
            }]
        }
    };
var trace1 = document.getElementById("canvas1.1");
var trace1_ch_other1 = document.getElementById("canvas2.1");
var trace1_ch_other2 = document.getElementById("canvas3.1");
var mseed1 = new Chart(trace1, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
        	label: '',
            data: [],
            backgroundColor: traceColors.background,
            borderColor: traceColors.border
        }]
    },
    options: {
    	scales: timeOpts.scales,
    	arrivalTime: undefined,
    	snrWindowInSec: 0
    }
});
var mseed2 = new Chart(trace1_ch_other1, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: '',
            data: [],
        }]
    },
    options: timeOpts
});
var mseed3 = new Chart(trace1_ch_other2, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: '',
            data: [],
         }]
    },
    options: timeOpts
});

var trace1_snr = document.getElementById("canvas1.2");
var trace1_cum = document.getElementById("canvas1.3");
var trace1_env = document.getElementById("canvas1.4");
var mseed_snr = new Chart(trace1_snr, {
    type: 'line',
    data: {
        //labels: [],
        datasets: [{
            label: '',
            data: [],
            backgroundColor: snrColors.noise.background,
            borderColor: snrColors.noise.border
        },
        {
        	label: '',
            data: [],
            backgroundColor: snrColors.signal.background,
            borderColor: snrColors.signal.border
        }]
    },
    options: {
        scales: {
            /* NOTE: log scale supported for EITHER x or y axis:
            	http://www.chartjs.org/docs/#scales-logarithmic-scale
            	*/
            yAxes: [{
            	type: 'logarithmic',
            	ticks: {
            		// Avoid
                    callback: function(value, index, values) {
                    	//the scale is logarithmic, get only powers of ten:
                    	// this makes less labels (too dense)
                    	var printLabel = index == 0 || index == values.length - 1;
                    	if (!printLabel && (index > 1) && (index < values.length - 2)){
                    		//apparently, Math.log10 is not fully supported, so do:
                        	var valueLog10 = Math.log(value) / Math.LN10;
                    		printLabel = Math.abs(Math.round(valueLog10) - valueLog10) < 0.0001;
                    		if (printLabel){
	                    		value = Math.pow(10, Math.round(valueLog10));
                    		}
                    	}
            			if (!printLabel){
            				return ""
            			}
            			var val = value.toExponential();
            			//to be sure (especially if index=0 or values.length-1),
            			//brute force approach:
            			if (val.length > 10){
            				return "";
            			}
                    	return val;
                    }
            	}
            }],
            xAxes:[{
            	gridLines : {
            		zeroLineColor : "rgba(0, 0, 0, 0.1)"
                },
            	type: 'linear',
                position: 'bottom',
            	ticks: {
            		//beginAtZero: true,
                    // Convert a log number to its real number by means of 10^value:
                    //(round to max two decimal digits)
                    callback: function(value, index, values) {
                    	return "" + Math.round(Math.pow(10,value) * 100) / 100;
                    }
            	}
            }]
        }
    }
});
var mseed_cum = new Chart(trace1_cum, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: '',
            data: [],
            backgroundColor: traceColors.background,
            borderColor: traceColors.border
        }]
    },
    options: {
    	scales: timeOpts.scales,
    	cumT5: undefined,
    	cumT95: undefined
    }
});
var mseed_env = new Chart(trace1_env, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
        	fill: true,
            label: '',
            data: [],
            backgroundColor: traceColors.background,
            borderColor: traceColors.border
         }]
    },
    options: timeOpts
});

</script>
<!--  Load our angular app after having loaded Charts (for safety)   -->
<script src="static/js/app.js"></script>

</html>