<!DOCTYPE html>
<html>
<head>
<script src="static/js/moment.min.js"></script>
<script src="static/js/Chart.min.js"></script>
<script src="static/js/angular.min.js"></script>
<link href="static/css/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="static/css/mystyle.css" rel="stylesheet" media="screen">
<title>{{ title }}</title>
</head>

<body ng-app="myApp" ng-controller="myController">


<div class="container-fluid fullheight">
<div class="row fullheight">
	<div class="col-md-2 fullheight">
		<div class=navigator>
			Segment {{ '{{' }} currentIndex + 1 {{ '}}' }} of {{ '{{' }} elements.length {{ '}}' }}
			<!-- as these two buttons are right floated (see mystyle.css), the order they wil be displayed is
			inverse to the order they appear here, so we invert them
			order  -->
			<button class='btn btn-default' ng-click="setNextIndex()" >&rarr;</button>
			<button class='btn btn-default' ng-click="setPreviousIndex()">&larr;</button>
		</div>
		<div class="checkbox">
    		<label>
      			<input type="checkbox" ng-model="showFiltered"
      				ng-change="toggleFilter()"> View filtered
    		</label>
  		</div>
		<div class="panel panel-default">
  			<!-- Default panel contents -->
  			<div class="panel-heading">{{ '{{' }} getCurrentSegmentName() {{ '}}' }}</div>
  				<div class="panel-body">
  					<ul class="segment-info example-animate-container">
						<li class="animate-repeat" ng-repeat="info in data.metadata">
					      		<strong>{{ '{{' }} info[0] {{ '}}' }}</strong>: {{ '{{' }} info2str(info[0], info[1]) {{ '}}' }}
					    </li>
					    <li class="animate-repeat" ng-if="infos.length == 0">
					      		<strong>No info available</strong>
					    </li>
					</ul>
  				</div>
  		</div>
  		<div class="panel panel-default">
  			<!-- Default panel contents -->
  			<div class="panel-heading">Class</div>
  				<!-- <ul class="nav nav-tabs">
				  <li ng-class="{{ '{' }} 'active' : classTabSelIndex != 1 , '' :  classTabSelIndex == 1 {{ '}' }}"><a ng-click="setClassTab(0)" href="#">Set class</a></li>
				  <li ng-class="{{ '{' }} 'active' : classTabSelIndex == 1 , '' :  classTabSelIndex != 1 {{ '}' }}"><a ng-click="setClassTab(1)" href="#">Filter</a></li>
				</ul> -->
  			
  				<div class="panel-body">
  					<div ng-show="classTabSelIndex != 1" class="segment-class example-animate-container">
						<div ng-repeat="class in classes">
						<label>
						<input type='radio' ng-click="setCurrentSegmentClass()" class="animate-repeat" ng-model="data.class_id" value="{{ '{{' }} class.Id {{ '}}' }}">
					      		{{ '{{' }} class.Id {{ '}}' }}: <strong>{{ '{{' }} class.Label {{ '}}' }}</strong> ({{ '{{' }} class.Count {{ '}}' }}) 
					    </label>
					    </div>
					</div>
					<!-- <div ng-show="classTabSelIndex == 1" class="segment-class example-animate-container">
						<div ng-repeat="class in classes">
						<input type='checkbox' class="animate-repeat" ng-model="data.class_id" value="{{ '{{' }} class.Id {{ '}}' }}">
					      		{{ '{{' }} class.Id {{ '}}' }}: <strong>{{ '{{' }} class.Label {{ '}}' }}</strong> ({{ '{{' }} class.Count {{ '}}' }}) 
					    </div>
					</div> -->
  				</div>
  		</div>
	</div>
	<div class="col-md-6 fullheight pos-relative">
		<div class="one-third-height">
			<canvas id="canvas1.1"></canvas>
		</div>
		<div class="one-third-height">
			<canvas id="canvas2.1"></canvas>
		</div>
		<div class="one-third-height">
			<canvas id="canvas3.1"></canvas>
		</div>
	</div>
	<div class="col-md-4 fullheight pos-relative">
		<div class="one-third-height">
			<canvas id="canvas1.2"></canvas>
		</div>
		<div class="one-third-height">
			<canvas id="canvas1.3"></canvas>
		</div>
		<div class="one-third-height">
			<canvas id="canvas1.4"></canvas>
		</div>
	</div>
</div>

</div>
	
</body>
<script type="text/javascript">
/* these two options together make canvas (plots) resize automatically according to parent container size */
Chart.defaults.global.responsive = true; /* what happens?? */
Chart.defaults.global.maintainAspectRatio = false;
Chart.defaults.global.elements.point.radius = 0;
Chart.defaults.global.elements.line.fill = false;
Chart.defaults.global.elements.line.borderWidth = 1;
//Chart.defaults.global.elements.line.backgroundColor = "rgba(75,192,192,0.4)";
//Chart.defaults.global.elements.line.borderColor = "rgba(75,192,192,1)";


/* extends a line chart which displays the arrival time.
 * 
 */

 //first define the snr colors:
var snrColors = {
	noise: {
		border: "rgba(0, 125, 0, 0.55)",
		background: "rgba(0, 125, 0, 0.1)"
	},
	signal: {
		border: "rgba(125, 0, 0, 0.55)",
		background: "rgba(125, 0, 0, 0.1)"
	}
};

var traceColors = {
	border: "rgba(75,192,192,0.8)",
	background: "rgba(75,192,192,0.1)"
}

var arrivalTimeColor = "rgba(0, 0, 42, 0.7)";

var originalLineDraw = Chart.controllers.line.prototype.draw;
Chart.helpers.extend(Chart.controllers.line.prototype, {
    draw: function () {
    	originalLineDraw.apply(this, arguments);
    	
    	var chart = this.chart;
        var ctx = chart.chart.ctx;

        //IMPORTANT: ALL TIME UNITS IN MILLISECONDS!!!!
        //as a remindeer, a timestamp in milliseconds has 13 chars if integer
        var aTime = chart.config.options.arrivalTime;
        var snrDtInMSec = chart.config.options.snrWindowInSec * 1000;
        var cumt5 = chart.config.options.cumT5;
        var cumt95 = chart.config.options.cumT95;
        
        var aTimeSet = aTime || aTime === 0;
        var t5_95RegionSet = cumt5 && cumt95 && cumt5 < cumt95;
        
        if (aTimeSet || t5_95RegionSet){
        	ctx.save();
        	
        	var xaxis = chart.scales['x-axis-0'];
            var yaxis = chart.scales['y-axis-0'];
            //save a reference toi current fill style
  		  	var textFillStyle = ctx.fillStyle;
  		  	
        	if(aTimeSet){
	            var x1 = xaxis.getPixelForValue(moment(aTime));
	            
	            // paint line
	            ctx.beginPath();
	            ctx.moveTo(x1, yaxis.top + 12);
	            ctx.strokeStyle = arrivalTimeColor;
	            ctx.lineTo(x1, yaxis.bottom);
	            ctx.stroke();
	            
	         	  // write TODAY
	            ctx.fillStyle = textFillStyle;
			  	ctx.textAlign = 'center';
	            ctx.fillText("arrival time", x1, yaxis.top);
	
	            //paint rects:
	            if (snrDtInMSec){
	          	  var x0 = xaxis.getPixelForValue(moment(aTime - snrDtInMSec));
	                var x2 = xaxis.getPixelForValue(moment(aTime + snrDtInMSec));
	           
	  	          ctx.fillStyle = snrColors.noise.background;
	  			  ctx.fillRect(x0, yaxis.top, x1-x0, yaxis.bottom - yaxis.top);
	  			  ctx.fillStyle = snrColors.signal.background;
	  			  ctx.fillRect(x1, yaxis.top, x2-x1, yaxis.bottom - yaxis.top);
	            }
        	}
        	
        	if(t5_95RegionSet){
        		var x0 = xaxis.getPixelForValue(moment(cumt5));
            	var x2 = xaxis.getPixelForValue(moment(cumt95));
         
	          	ctx.fillStyle = traceColors.background;
			  	ctx.fillRect(x0, yaxis.top, x2-x0, yaxis.bottom - yaxis.top);
			  	
			  	ctx.fillStyle = textFillStyle;
			  	ctx.textAlign = 'center';
	          	ctx.fillText("5% to 95% Region", (x2+x0)/2, yaxis.top);
            }
        	
        	ctx.restore();
        }

    }
}); 


/*
init charts: 
*/
// first init the dict of options for all time plots:
var timeOpts = {
        scales: {
        	xAxes: [{
                type: 'time',
                time: {
                    parser: function(value){
                    	// override this cause moment parses as local time,
                    	// but we have times as utc
                    	// for info see:
                    	// http://www.chartjs.org/docs/#scales-time-scale
                    	// http://momentjs.com/docs/#/parsing/utc/
                		return moment.utc(value);
                    }
                },
                ticks:{
                	maxRotation: 0
                }
            }]
        }
    };
var trace1 = document.getElementById("canvas1.1");
var trace1_ch_other1 = document.getElementById("canvas2.1");
var trace1_ch_other2 = document.getElementById("canvas3.1");
var mseed1 = new Chart(trace1, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
        	label: '',
            data: [],
            backgroundColor: traceColors.background,
            borderColor: traceColors.border
        }]
    },
    options: {
    	scales: timeOpts.scales,
    	arrivalTime: undefined,
    	snrWindowInSec: 0
    }
});
var mseed2 = new Chart(trace1_ch_other1, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: '',
            data: [],
        }]
    },
    options: timeOpts
});
var mseed3 = new Chart(trace1_ch_other2, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: '',
            data: [],
         }]
    },
    options: timeOpts
});

var trace1_snr = document.getElementById("canvas1.2");
var trace1_cum = document.getElementById("canvas1.3");
var trace1_env = document.getElementById("canvas1.4");
var mseed_snr = new Chart(trace1_snr, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: '',
            data: [],
            backgroundColor: snrColors.noise.background,
            borderColor: snrColors.noise.border
        },
        {
        	label: '',
            data: [],
            backgroundColor: snrColors.signal.background,
            borderColor: snrColors.signal.border
        }]
    },
    options: {
        scales: {
            /* NOTE: log scale supported for EITHER x or y axis:
            	http://www.chartjs.org/docs/#scales-logarithmic-scale
            	*/
            yAxes: [{
            	type: 'logarithmic',
            	 ticks: {
                 /*    min: 1,
                    max: 13382290 */ 
            	}
            }],
            xAxes:[{
            	/* type: 'logarithmic',
            	position: 'bottom', */
            	ticks: {
            		/*  min: 1,
                     max: 10, */
                	maxRotation: 0
            	}
            }]
        }
    }
});
var mseed_cum = new Chart(trace1_cum, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: '',
            data: [],
            backgroundColor: traceColors.background,
            borderColor: traceColors.border
        }]
    },
    options: {
    	scales: timeOpts.scales,
    	cumT5: undefined,
    	cumT95: undefined
    }
});
var mseed_env = new Chart(trace1_env, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
        	fill: true,
            label: '',
            data: [],
            backgroundColor: traceColors.background,
            borderColor: traceColors.border
         }]
    },
    options: timeOpts
});

</script>
<!--  Load our angular app after having loaded Charts (for safety)   -->
<script src="static/js/app.js"></script>

</html>