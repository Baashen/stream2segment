<!DOCTYPE html>
<html>
<head>
	

	<title>Download statistics</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Leaflet -->
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.2/dist/leaflet.css" />
	<script src="https://unpkg.com/leaflet@1.0.2/dist/leaflet.js"></script>

	<!-- Load Esri Leaflet from CDN -->
	<script src="https://unpkg.com/esri-leaflet@2.0.6"></script>
	
	<style>
	body{
		font-size: smaller;
		font-family: "Lucida Sans Unicode", Arial, Helvetica, "Trebuchet MS", Verdana, sans-serif;
	}
	.leaflet-popup-content{
	    max-height: 60vh;
    	overflow: auto;
	}
	.leaflet-popup-content .border-top td{
		border-top: 1px solid #ddd;
	}
	.leaflet-popup-content .border-bottom td{
		border-bottom: 1px solid #ddd;
	}
	.leaflet-popup-content .info{
		margin-top:1ex;
	}
	#legend label{
		display:block;
	}
	#legend{
		line-height:1.5em;
		overflow:auto; margin-left:80vw; height:98vh;
		/* styling appearence: */
		color: white;
	    background-color: rgba(0,0,0,0.8);
	    padding: 14px;
	    border-top-right-radius: 8px;
	    border-bottom-right-radius: 8px;
	    box-sizing: border-box;
	}
	div.header{
		border-bottom: 1px solid #ddd;
		margin-bottom: 1em;
	    padding-bottom: 0.5em;
	}
	div#legend > div:not(:first-child){
		margin-top: 2em;
	}
	#map{
		width:79vw; height:98vh; float:left;
	}
	.legend_explain{
		text-align: justify;
	}
	</style>
	
</head>
<body>

<div id=map></div>
<div id=legend>
	<div>
		<div class="header">Legend</div>
		<div class="legend_explain">
		Each circle denotes a station 
		whose color represents the waveform data availability (white: no data, full color: 100% data)
		<p>
		For each station, data availability is computed as the number of well-formed waveform segments divided by the
		total number of segments downloaded.
		<p>Well formed segments are those without warnings/ errors defined below: you can
		check/uncheck them to define which segments should be considered well-formed:
		the map will update colors and infos dynamically.
		<p>Each circle is clickable and will display detailed download information.
		The control on the top right corner allows the user to visualize datacenter-specific statistics.
		</div>
	</div>
	<div>
		<div class="header">Warnings/ errors:</div>
		<div>
		{% for item in warnerrs_labels %}
			<label for="warnerr_{{loop.index}}">
				<input id="warnerr_{{loop.index}}" class='warnerr' data-type="{{ item }}" checked type='checkbox' onchange='drawMap()'> {{ item }}
			</label>
		{% endfor %}
		</div>
	</div>
</div>
</body>
<script>
	var map = new L.Map('map');
	var baseLayer = L.esri.basemapLayer("Oceans").addTo(map);
	var layerControl = L.control.layers().addTo(map);
	// start the map in South-East England
	//map.setView(new L.LatLng(51.3, 0.7),9);
	
	map.fitBounds([
    [44.11217, 0.3363],
    [59.42283, 20.267]
	]);
	
	function unpack(element){
		//unpacks warnings / errors returning [num_errors_warnings, div_content]
		var ret = "<table>";
		var count = 0;
		for (var key in element){
			var mseeds = element[key];
			count += mseeds.length;
			ret += "<tr><td>" + key + "</td><td>(" + mseeds.length +" mseeds)</td></tr>";
			mseeds.forEach(function(elm, index){
				ret += "<tr><td style='text-align:right'>"+index+"</td><td>" + elm + "</td></tr>";
			});
			ret += "";
		}
		if (count == 0){
			ret = "none";
		}else{
			ret +="</table>";
		}
		return [count, ret];
	};

	function drawMap(){
		var domLevels = document.querySelectorAll("input[type=checkbox].warnerr");
		var levels = {};
		for (var i=0; i < domLevels.length; i++){
			levels[domLevels[i].getAttribute('data-type')] = domLevels[i].checked;
		}
		
		var d = DATA;
		var cols = d.columns;
		var w_ = WARNINGS;
		var e_ = ERRORS;
		var dcens = {}; //stores layers to checkbox stations of a single datacenter
		//var we = {}; //stores layers to checkbox stations with given error/warning
		var _MARKERS = window._MARKERS || [];
		var isFirstDraw = window._MARKERS ? false : true;
		d.index.forEach(function(station, index){
			var vals = d.data[index];
			var lat = vals[0];
			var lon = vals[1];
			var total = vals[2];
			var dcen = vals[3];
			var malformed = 0;
			// calculate ok's based on the selected levels:
			for (var i=4; i < DATA.columns.length; i++){
				if (!levels[DATA.columns[i]]){
					continue;
				}
				malformed += vals[i];
			}
			var ok = total - malformed;
			if (! (dcen in dcens)){
				dcens[dcen] = {'markers': [], 'total':0, 'ok':0};
			}
			var dc = dcens[dcen];
			dc.total += total;
			dc.ok += ok;
			var gb = parseInt(0.5 + 255 * (1 - (total == 0 ? 0 : parseFloat(ok)/total)));
			//console.log(gb);
			
			var fillColor = "rgb(255, " + gb + "," + gb +")";
			var warns = w_[station];
			var errs = e_[station];
			// var hasWE = (warns != undefined || errs != undefined) ? true : false;
			var color = '#adadad';
			var circle = L.circleMarker([lat, lon], {
			    color: color,
			    opacity: 1,
			    weight: 1,
			    fillColor: fillColor,
			    fillOpacity: 1,
			    radius: 6
			});

			var warnings_ = unpack(warns || {});
			var errors_ = unpack(errs || {});
			
			var infostr = "<table class='info'>"+
				"<tr><td>Station:</td><td>" + station + "</td></tr>" +
				"<tr class='border-top'><td>lat</td><td>"+ lat + "</td></tr>"+
				"<tr><td>lon</td><td>"+ lon + "</td></tr>" +
				"<tr><td>d.c.</td><td>"+ dcen + "</td></tr>" +
				"<tr class='border-top'><td>miniSeeds</td><td>" + total + "</td></tr>" +
				"<tr><td>ok</td><td>" + ok + "</td></tr>" +
				"<tr><td>errors</td><td>" + errors_[0] + "</td></tr>" +
				"<tr><td>warnings</td><td>" + warnings_[0] + "</td></tr>" +
				"</table>";
			
			//infostr += "<div class='info'><div style='color:#e40000'>errors:</div>" + errors_[1] + "</div>";
			//infostr += "<div class='info'><div style='color:#0000e4'>warnings:</div>" + warnings_[1] + "</div>";
			
			circle.bindPopup(infostr);
			
			dc.markers.push(circle);
		});
		
		// we did not find any better solution than redrawing each layer
		map.eachLayer(function (layer) {
			if (layer == baseLayer){
				return;
			}
   		 	map.removeLayer(layer);
   		 	layerControl.removeLayer(layer);
		});

		for (var dcen in dcens){
			var val = dcens[dcen];
			var lg = L.layerGroup(val.markers);
			var title = dcen + "  - total: " + val.total +", ok: " + val.ok +" (" + Math.round(100*parseFloat(val.ok)/val.total)+ "%)"; 
			layerControl.addOverlay(lg, title);
			lg.addTo(map);
		}
	
	};	

	var DATA = {{stations}};
	var WARNINGS = {{warnings}};
	var ERRORS = {{errors}};

	drawMap();
</script>
</html>